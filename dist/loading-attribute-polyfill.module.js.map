{"version":3,"file":"loading-attribute-polyfill.module.js","sources":["../src/loading-attribute-polyfill.js"],"sourcesContent":["/*\n * Loading attribute polyfill - https://github.com/mfranzke/loading-attribute-polyfill-with-serviceworker\n * @license Copyright(c) 2019 by Maximilian Franzke\n * Credits for the initial kickstarter / script to @Sora2455, and supported by @cbirdsong, @eklingen, @DaPo, @nextgenthemes, @diogoterremoto, @dracos, @Flimm, @TomS-, @vinyfc93, @JordanDysart and @denyshutsal - many thanks for that !\n */\n/*\n * A minimal and dependency-free vanilla JavaScript loading attribute polyfill.\n * Supports standard's functionality and tests for native support upfront.\n * Elsewhere the functionality gets emulated with the support of ServiceWorker.\n */\n\nimport './loading-attribute-polyfill.css';\n\nconst config = {\n\tintersectionObserver: {\n\t\t// Start download if the item gets within 256px in the Y axis\n\t\trootMargin: '0px 0px 256px 0px',\n\t\tthreshold: 0.01,\n\t},\n\tlazyImage: 'img[loading=\"lazy\"]',\n\tlazyIframe: 'iframe[loading=\"lazy\"]',\n};\n\n// Device/browser capabilities object\nconst capabilities = {\n\tloading: {\n\t\timage: 'loading' in HTMLImageElement.prototype,\n\t\tiframe: 'loading' in HTMLIFrameElement.prototype,\n\t},\n\tscrolling: 'onscroll' in window,\n};\n\n// Nodelist foreach polyfill / source: https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach#polyfill\nif (window.NodeList && !NodeList.prototype.forEach) {\n\tNodeList.prototype.forEach = Array.prototype.forEach;\n}\n\n// Define according to browsers support of the IntersectionObserver feature (missing e.g. on IE11 or Safari 11)\nlet intersectionObserver;\n\nif ('IntersectionObserver' in window) {\n\tintersectionObserver = new IntersectionObserver(\n\t\tonIntersection,\n\t\tconfig.intersectionObserver\n\t);\n}\n\n/**\n * Remove the URL query parts for the lazy loaded item\n * @param {String} urlString The URL to remove the URL query parts from\n */\nfunction removeLazyPolyfillURLParts(urlString) {\n\treturn urlString.replace(\n\t\t/(&|&amp;)?(loading=lazy|image-width=\\d*|image-height=\\d*)/gi,\n\t\t''\n\t);\n}\n\n/**\n * Remove the lazy query from the URL - now that the regular elements URL is referenced within the document, it will load now\n * @param {Object} lazyItem Current item to be referenced after lazy loading.\n */\nfunction createRegularReference(lazyItem) {\n\tlet mediaItems = [lazyItem];\n\n\t// Just in case the img is the decendent of a picture element, check for source tags\n\tif (lazyItem.parentNode.tagName.toLowerCase() === 'picture') {\n\t\tmediaItems = Array.prototype.slice.call(\n\t\t\tlazyItem.parentNode.querySelectorAll('source')\n\t\t);\n\t}\n\n\tmediaItems.push(lazyItem);\n\n\tmediaItems.forEach((item) => {\n\t\tif (item.hasAttribute('srcset')) {\n\t\t\titem.srcset = removeLazyPolyfillURLParts(item.srcset);\n\t\t}\n\n\t\titem.src = removeLazyPolyfillURLParts(item.src);\n\n\t\t// Modify the data attribute on the current status\n\t\titem.dataset.loadingLazy = 'loading';\n\t});\n}\n\n/**\n * Handle IntersectionObservers callback\n * @param {Object} entries Target elements Intersection observed changes\n * @param {Object} observer IntersectionObserver instance reference\n */\nfunction onIntersection(entries, observer) {\n\tentries.forEach((entry) => {\n\t\t// Mitigation for EDGE lacking support of .isIntersecting until v15, compare to e.g. https://github.com/w3c/IntersectionObserver/issues/211#issuecomment-309144669\n\t\tif (entry.intersectionRatio === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the item is visible now, load it and stop watching it\n\t\tconst lazyItem = entry.target;\n\n\t\tobserver.unobserve(lazyItem);\n\n\t\tcreateRegularReference(lazyItem);\n\t});\n}\n\n/**\n * Handle printing the page\n */\nfunction onPrinting() {\n\tif (typeof window.matchMedia === 'undefined') {\n\t\treturn;\n\t}\n\n\tconst mediaQueryList = window.matchMedia('print');\n\n\tmediaQueryList.addListener((mql) => {\n\t\tif (mql.matches) {\n\t\t\tdocument\n\t\t\t\t.querySelectorAll(config.lazyImage + ',' + config.lazyIframe)\n\t\t\t\t.forEach((lazyItem) => {\n\t\t\t\t\tcreateRegularReference(lazyItem);\n\t\t\t\t});\n\t\t}\n\t});\n}\n\n/**\n * Retrieve the image and iframe 'lazy load' elements and prepare them for display\n * @param {Object} mediaTag image or iframe HTML tag\n */\nfunction prepareElement(mediaTag) {\n\tif (\n\t\t((mediaTag.tagName?.toLowerCase() === 'img' ||\n\t\t\tmediaTag.tagName?.toLowerCase() === 'picture') &&\n\t\t\t!capabilities.loading.image) ||\n\t\t(mediaTag.tagName?.toLowerCase() === 'iframe' &&\n\t\t\t!capabilities.loading.iframe)\n\t) {\n\t\tif (typeof intersectionObserver !== 'undefined') {\n\t\t\tconst observedElement = mediaTag;\n\n\t\t\t// Modify the data attribute on the current status\n\t\t\tobservedElement.dataset.loadingLazy = 'registered';\n\n\t\t\t// Observe the item so that loading could start when it gets close to the viewport\n\t\t\tintersectionObserver.observe(observedElement);\n\t\t} else {\n\t\t\tcreateRegularReference(mediaTag);\n\t\t}\n\t}\n}\n\n/**\n * Get all the img and iframe lazy loading tags on the page, prepare each and any one of them and setup the printing\n */\nconst prepareElements = () => {\n\tconst lazyLoadAreas = document.querySelectorAll(\n\t\tconfig.lazyImage + ',' + config.lazyIframe\n\t);\n\n\tlazyLoadAreas.forEach((element) => prepareElement(element));\n\n\t// Bind for someone printing the page\n\tonPrinting();\n};\n\n// If the page has loaded already, run setup - if it hasn't, run as soon as it has.\n// document.readyState values: https://www.w3schools.com/jsref/prop_doc_readystate.asp\nif (/comp|inter/.test(document.readyState)) {\n\tprepareElements();\n} else if ('addEventListener' in document) {\n\tdocument.addEventListener('DOMContentLoaded', () => {\n\t\tprepareElements();\n\t});\n} else {\n\tdocument.attachEvent('onreadystatechange', () => {\n\t\tif (document.readyState === 'complete') {\n\t\t\tprepareElements();\n\t\t}\n\t});\n}\n\nconst loadingAttributePolyfill = {\n\tprepareElement,\n};\n\nexport default loadingAttributePolyfill;\n"],"names":["capabilities","HTMLImageElement","prototype","HTMLIFrameElement","intersectionObserver","removeLazyPolyfillURLParts","urlString","replace","createRegularReference","lazyItem","mediaItems","parentNode","tagName","toLowerCase","Array","slice","call","querySelectorAll","push","forEach","item","hasAttribute","srcset","src","dataset","loadingLazy","prepareElement","mediaTag","observedElement","observe","window","NodeList","IntersectionObserver","entries","observer","entry","intersectionRatio","target","unobserve","rootMargin","threshold","prepareElements","document","config","element","matchMedia","addListener","mql","matches","test","readyState","addEventListener","attachEvent","loadingAttributePolyfill"],"mappings":"AAaA,MAWMA,EAEG,YAAaC,iBAAiBC,UAFjCF,EAGI,YAAaG,kBAAkBD,UAWzC,IAAIE,EAaJ,SAASC,EAA2BC,GACnC,OAAOA,EAAUC,QAChB,8DACA,IAQF,SAASC,EAAuBC,GAC/B,IAAIC,EAAa,CAACD,GAGgC,YAA9CA,EAASE,WAAWC,QAAQC,gBAC/BH,EAAaI,MAAMZ,UAAUa,MAAMC,KAClCP,EAASE,WAAWM,iBAAiB,YAIvCP,EAAWQ,KAAKT,GAEhBC,EAAWS,QAASC,IACfA,EAAKC,aAAa,YACrBD,EAAKE,OAASjB,EAA2Be,EAAKE,SAG/CF,EAAKG,IAAMlB,EAA2Be,EAAKG,KAG3CH,EAAKI,QAAQC,YAAc,YAkD7B,SAASC,EAAeC,aACvB,IACuC,kBAApCA,EAASf,kBAASC,gBACiB,sBAApCc,EAASf,kBAASC,kBACjBb,GACmC,qBAApC2B,EAASf,kBAASC,iBACjBb,EAEF,QAAoC,IAAzBI,EAAsC,CAChD,MAAMwB,EAAkBD,EAGxBC,EAAgBJ,QAAQC,YAAc,aAGtCrB,EAAqByB,QAAQD,QAE7BpB,EAAuBmB,GAxHAG,OAItBA,OAAOC,WAAaA,SAAS7B,UAAUiB,UAC1CY,SAAS7B,UAAUiB,QAAUL,MAAMZ,UAAUiB,SAM1C,yBAA0BW,SAC7B1B,EAAuB,IAAI4B,qBAkD5B,SAAwBC,EAASC,GAChCD,EAAQd,QAASgB,IAEhB,GAAgC,IAA5BA,EAAMC,kBACT,OAID,MAAM3B,EAAW0B,EAAME,OAEvBH,EAASI,UAAU7B,GAEnBD,EAAuBC,MAzFF,CAErB8B,WAAY,oBACZC,UAAW,OA4Ib,MAAMC,EAAkB,KACDC,SAASzB,iBAC9B0B,8CAGaxB,QAASyB,GAAYlB,EAAekB,SAnDjB,IAAtBd,OAAOe,YAIKf,OAAOe,WAAW,SAE1BC,YAAaC,IACvBA,EAAIC,SACPN,SACEzB,iBAAiB0B,8CACjBxB,QAASV,IACTD,EAAuBC,QAgDxB,aAAawC,KAAKP,SAASQ,YAC9BT,IACU,qBAAsBC,SAChCA,SAASS,iBAAiB,mBAAoB,KAC7CV,MAGDC,SAASU,YAAY,qBAAsB,KACd,aAAxBV,SAASQ,YACZT,MAKGY,MAAAA,EAA2B,CAChC3B,eAAAA"}