{"version":3,"file":"loading-attribute-polyfill-with-serviceworker.module.js","sources":["../src/loading-attribute-polyfill-with-serviceworker.js"],"sourcesContent":["/*\n * Loading attribute polyfill - https://github.com/mfranzke/loading-attribute-polyfill-with-serviceworker\n * @license Copyright(c) 2019 by Maximilian Franzke\n * Credits for the initial kickstarter / script to @Sora2455, and supported by @cbirdsong, @eklingen, @DaPo, @nextgenthemes, @diogoterremoto, @dracos, @Flimm, @TomS-, @vinyfc93, @JordanDysart and @denyshutsal - many thanks for that !\n */\n/*\n * A minimal and dependency-free vanilla JavaScript loading attribute polyfill.\n * Supports standard's functionality and tests for native support upfront.\n * Elsewhere the functionality gets emulated with the support of Service Worker.\n */\n\nimport './loading-attribute-polyfill-with-serviceworker.css';\n\nconst config = {\n\tintersectionObserver: {\n\t\t// Start download if the item gets within 256px in the Y axis\n\t\trootMargin: '0px 0px 256px 0px',\n\t\tthreshold: 0.01,\n\t},\n\tlazyImage: 'img[loading=\"lazy\"]',\n\tlazyIframe: 'iframe[loading=\"lazy\"]',\n};\n\n// Device/browser capabilities object\nconst capabilities = {\n\tloading: {\n\t\timage: 'loading' in HTMLImageElement.prototype,\n\t\tiframe: 'loading' in HTMLIFrameElement.prototype,\n\t},\n\tscrolling: 'onscroll' in window,\n};\n\n// Nodelist foreach polyfill / source: https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach#polyfill\nif (window.NodeList && !NodeList.prototype.forEach) {\n\tNodeList.prototype.forEach = Array.prototype.forEach;\n}\n\n// Define according to browsers support of the IntersectionObserver feature (missing e.g. on IE11 or Safari 11)\nlet intersectionObserver;\n\nif ('IntersectionObserver' in window) {\n\tintersectionObserver = new IntersectionObserver(\n\t\tonIntersection,\n\t\tconfig.intersectionObserver\n\t);\n}\n\n/**\n * Remove the URL query parts for the lazy loaded item\n * @param {String} urlString The URL to remove the URL query parts from\n */\nfunction removeLazyPolyfillURLParts(urlString) {\n\treturn urlString.replace(\n\t\t/(&|&amp;)?(loading=lazy|image-width=\\d*|image-height=\\d*)/gi,\n\t\t''\n\t);\n}\n\n/**\n * Remove the lazy query from the URL - now that the regular elements URL is referenced within the document, it will load now\n * @param {Object} lazyItem Current item to be referenced after lazy loading.\n */\nfunction createRegularReference(lazyItem) {\n\tlet mediaItems = [lazyItem];\n\n\t// Just in case the img is the decendent of a picture element, check for source tags\n\tif (lazyItem.parentNode.tagName.toLowerCase() === 'picture') {\n\t\tmediaItems = Array.prototype.slice.call(\n\t\t\tlazyItem.parentNode.querySelectorAll('source')\n\t\t);\n\t}\n\n\tmediaItems.push(lazyItem);\n\n\tfor (const item of mediaItems) {\n\t\tif (item.hasAttribute('srcset')) {\n\t\t\titem.srcset = removeLazyPolyfillURLParts(item.srcset);\n\t\t}\n\n\t\titem.src = removeLazyPolyfillURLParts(item.src);\n\n\t\t// Modify the data attribute on the current status\n\t\titem.dataset.loadingLazy = 'loading';\n\t}\n}\n\n/**\n * Handle IntersectionObservers callback\n * @param {Object} entries Target elements Intersection observed changes\n * @param {Object} observer IntersectionObserver instance reference\n */\nfunction onIntersection(entries, observer) {\n\tfor (const entry of entries) {\n\t\t// Mitigation for EDGE lacking support of .isIntersecting until v15, compare to e.g. https://github.com/w3c/IntersectionObserver/issues/211#issuecomment-309144669\n\t\tif (entry.intersectionRatio === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If the item is visible now, load it and stop watching it\n\t\tconst lazyItem = entry.target;\n\n\t\tobserver.unobserve(lazyItem);\n\n\t\tcreateRegularReference(lazyItem);\n\t}\n}\n\n/**\n * Handle printing the page\n */\nfunction onPrinting() {\n\tif (typeof window.matchMedia === 'undefined') {\n\t\treturn;\n\t}\n\n\tconst mediaQueryList = window.matchMedia('print');\n\n\tmediaQueryList.addListener((mql) => {\n\t\tif (mql.matches) {\n\t\t\tfor (const lazyItem of document.querySelectorAll(\n\t\t\t\tconfig.lazyImage + ',' + config.lazyIframe\n\t\t\t)) {\n\t\t\t\tcreateRegularReference(lazyItem);\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * Retrieve the image and iframe 'lazy load' elements and prepare them for display\n * @param {Object} mediaTag image or iframe HTML tag\n */\nfunction prepareElement(mediaTag) {\n\tif (\n\t\t(mediaTag.tagName?.toLowerCase() === 'img' && capabilities.loading.image) ||\n\t\t(mediaTag.tagName?.toLowerCase() === 'iframe' &&\n\t\t\tcapabilities.loading.iframe)\n\t) {\n\t\treturn false;\n\t}\n\n\tif (typeof intersectionObserver === 'undefined') {\n\t\tcreateRegularReference(mediaTag);\n\t} else {\n\t\tconst observedElement = mediaTag;\n\n\t\t// Modify the data attribute on the current status\n\t\tobservedElement.dataset.loadingLazy = 'registered';\n\n\t\t// Observe the item so that loading could start when it gets close to the viewport\n\t\tintersectionObserver.observe(observedElement);\n\t}\n}\n\n/**\n * Get all the img and iframe lazy loading tags on the page, prepare each and any one of them and setup the printing\n */\nconst prepareElements = () => {\n\tfor (const element of document.querySelectorAll(\n\t\tconfig.lazyImage + ',' + config.lazyIframe\n\t)) {\n\t\tprepareElement(element);\n\t}\n\n\t// Bind for someone printing the page\n\tonPrinting();\n};\n\n// If the page has loaded already, run setup - if it hasn't, run as soon as it has.\n// document.readyState values: https://www.w3schools.com/jsref/prop_doc_readystate.asp\nif (/comp|inter/.test(document.readyState)) {\n\tprepareElements();\n} else if ('addEventListener' in document) {\n\tdocument.addEventListener('DOMContentLoaded', () => {\n\t\tprepareElements();\n\t});\n} else {\n\tdocument.attachEvent('onreadystatechange', () => {\n\t\tif (document.readyState === 'complete') {\n\t\t\tprepareElements();\n\t\t}\n\t});\n}\n\nconst loadingAttributePolyfillWithServiceWorker = {\n\tprepareElement,\n};\n\nexport default loadingAttributePolyfillWithServiceWorker;\n"],"names":["capabilities","HTMLImageElement","prototype","HTMLIFrameElement","intersectionObserver","removeLazyPolyfillURLParts","urlString","replace","createRegularReference","lazyItem","mediaItems","parentNode","tagName","toLowerCase","Array","slice","call","querySelectorAll","push","item","hasAttribute","srcset","src","dataset","loadingLazy","prepareElement","mediaTag","observedElement","observe","window","NodeList","forEach","IntersectionObserver","entries","observer","entry","intersectionRatio","target","unobserve","rootMargin","threshold","prepareElements","element","document","config","matchMedia","addListener","mql","matches","test","readyState","addEventListener","attachEvent","loadingAttributePolyfillWithServiceWorker"],"mappings":"AAaA,MAWMA,EAEG,YAAaC,iBAAiBC,UAFjCF,EAGI,YAAaG,kBAAkBD,UAWzC,IAAIE,EAaJ,SAASC,EAA2BC,GACnC,OAAOA,EAAUC,QAChB,8DACA,IAQF,SAASC,EAAuBC,GAC/B,IAAIC,EAAa,CAACD,GAGgC,YAA9CA,EAASE,WAAWC,QAAQC,gBAC/BH,EAAaI,MAAMZ,UAAUa,MAAMC,KAClCP,EAASE,WAAWM,iBAAiB,YAIvCP,EAAWQ,KAAKT,GAEhB,IAAK,MAAMU,KAAQT,EACdS,EAAKC,aAAa,YACrBD,EAAKE,OAAShB,EAA2Bc,EAAKE,SAG/CF,EAAKG,IAAMjB,EAA2Bc,EAAKG,KAG3CH,EAAKI,QAAQC,YAAc,UAkD7B,SAASC,EAAeC,WACvB,GACsC,kBAApCA,EAASd,kBAASC,gBAA2Bb,GACT,qBAApC0B,EAASd,kBAASC,gBAClBb,EAED,SAGD,QAAoC,IAAzBI,EACVI,EAAuBkB,OACjB,CACN,MAAMC,EAAkBD,EAGxBC,EAAgBJ,QAAQC,YAAc,aAGtCpB,EAAqBwB,QAAQD,IAzHLE,OAItBA,OAAOC,WAAaA,SAAS5B,UAAU6B,UAC1CD,SAAS5B,UAAU6B,QAAUjB,MAAMZ,UAAU6B,SAM1C,yBAA0BF,SAC7BzB,EAAuB,IAAI4B,qBAkD5B,SAAwBC,EAASC,GAChC,IAAK,MAAMC,KAASF,EAAS,CAE5B,GAAgC,IAA5BE,EAAMC,kBACT,SAID,MAAM3B,EAAW0B,EAAME,OAEvBH,EAASI,UAAU7B,GAEnBD,EAAuBC,KAzFF,CAErB8B,WAAY,oBACZC,UAAW,OA4Ib,MAAMC,EAAkB,KACvB,IAAK,MAAMC,KAAWC,SAAS1B,iBAC9B2B,8CAEAnB,EAAeiB,QAlDiB,IAAtBb,OAAOgB,YAIKhB,OAAOgB,WAAW,SAE1BC,YAAaC,IAC3B,GAAIA,EAAIC,QACP,IAAK,MAAMvC,KAAYkC,SAAS1B,iBAC/B2B,8CAEApC,EAAuBC,MAgDvB,aAAawC,KAAKN,SAASO,YAC9BT,IACU,qBAAsBE,SAChCA,SAASQ,iBAAiB,mBAAoB,KAC7CV,MAGDE,SAASS,YAAY,qBAAsB,KACd,aAAxBT,SAASO,YACZT,MAKGY,MAAAA,EAA4C,CACjD5B,eAAAA"}